<html>
<head>
	<title>Buuuuble.io</title>
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link href="https://fonts.googleapis.com/css?family=Comfortaa" rel="stylesheet">
	<style>
	* {
		margin: 0;
		padding: 0;
    }
	</style>
</head>
<body height="100%" style="overflow: hidden">
	<canvas id="canvas" width="0" height="0" style="position: absolute; background-color: #FFFFFF;">get html5</canvas>
	<script src="frame.js"></script>
	
	<div id="startGUI">
	<div id="cover" style="position: absolute; top: 0; left: 0; height:100%; width:100%; background-color: #333; opacity: 0.2;"></div>
	<form style="position:absolute;" onsubmit="startGame();return false;">
		<input type="text" id="name"></input>
		<input type="submit" value="Start"></input>
	</form>
	</div>
</body>

<script>
	var ws;
	var frames = [];
	var lerpFrames = [];
	var frameTimes = [];
	var t = 0.0;
	var currentTime = Date.now();
	var prevTime = 0;
	var delta = 0;
	var framerate = (1.0/60) * 1000;
	
	class Bubble extends Actor {
		constructor(startx, starty, id) {
			super(startx, starty);
			this.controls = {
				up: false,
				left: false,
				down: false,
				right: false
			}
			this.id = id || -1;
			this.radius = 25;
			this.color = "#37C";
			
			this.extrax = 0;
			this.extray = 0;
			this.tarx = 0;
			this.tary = 0;
		}
		update() {
			if (playerid == this.id) {
				this.extrax *= 0.92;
				this.extray *= 0.92;
				
				if (this.controls.left) {
					this.extrax += (-100 - this.extrax) * 0.1;
				}
				if (this.controls.right) {
					this.extrax += (100 - this.extrax) * 0.1;
				}
				if (this.controls.up) {
					this.extray += (-100 - this.extray) * 0.1;
				}
				if (this.controls.down) {
					this.extray += (100 - this.extray) * 0.1;
				}
			}
		
			this.x += (this.tarx+this.extrax - this.x) * 0.1;
			this.y += (this.tary+this.extray - this.y) * 0.1;
		}
		render() {
			this.ctx.fillStyle = this.color;
			this.ctx.beginPath();
			this.ctx.arc(0, 0, this.radius, 0, 2 * Math.PI, false);
			this.ctx.fill();
		}
	}
	
	class BigCircle extends Actor {
		constructor() {
			super(0,0);
			this.gradient = this.ctx.createLinearGradient(-window.innerHeight/2, 0, window.innerHeight/2, 0);
			this.gradient.addColorStop(0, "#FF4446");
			this.gradient.addColorStop(0.5, "#EE2246");
			this.gradient.addColorStop(1, "#DD0046");
		}
		render() {
			this.ctx.fillStyle = this.gradient;
			this.ctx.beginPath();
			this.ctx.arc(0, 0, window.innerHeight/2/FRAME.scaleY, 0, 2 * Math.PI, false);
			this.ctx.fill();
		}
	}
	
	var playerid = -1;
	var player;
	var PLAYERS = [];
	
	function idOf(array, test) {
		for (var i = 0; i < array.length; i++) {
			if (array[i].id == test) {
				return id;
			}
		}
		return -1;
	}
	
	function indexFromId(array, test) {
	for (var i = 0; i < array.length; i++) {
			if (array[i].id == test) {
				return i;
			}
		}
		return -1;
	}
	
	window.onload = function() {
		FRAME.init(1920, 1080, document.getElementById("canvas"));
		
		collection = new Collection();
		bigbubble = new BigCircle();
		
		main();
	}
	
	function main() {
		FRAME.clearScreen();
		prevTime = currentTime;
		currentTime = Date.now();
		delta = (currentTime-prevTime) / framerate;
		
		player = PLAYERS[indexFromId(PLAYERS, playerid)];
		
		if (player !== undefined) {
			//update client stuff for server
			var prevControls = JSON.stringify(player.controls);
			if (keyboard[87] == true) {
				player.controls.up = true;
			}
			else {
				player.controls.up = false;
			}
			if (keyboard[65] == true) {
				player.controls.left = true;
			}
			else {
				player.controls.left = false;
			}
			if (keyboard[83] == true) {
				player.controls.down = true;
			}
			else {
				player.controls.down = false;
			}
			if (keyboard[68] == true) {
				player.controls.right = true;
			}
			else {
				player.controls.right = false;
			}
			//send info to server if controls changed
			if (prevControls !== JSON.stringify(player.controls)) {
				ws.send('c' + JSON.stringify([playerid, player.controls]));
			}
		}
		
		//lerp
		if (lerpFrames[0] != undefined && lerpFrames[1] != undefined) {
			for (var i = 0; i < lerpFrames[0].length; i++) {
				if (indexFromId(PLAYERS, lerpFrames[0][i].id) == -1) {
					PLAYERS.push(new Bubble(lerpFrames[0][i].x, lerpFrames[0][i].y));
					PLAYERS[PLAYERS.length - 1].id = lerpFrames[0][i].id;
					collection.add(PLAYERS[PLAYERS.length - 1]);
				}
				
				var playerIndex = indexFromId(PLAYERS, lerpFrames[0][i].id);
				var lerpIndex = -1;
				for (var j = 0; j < lerpFrames[1].length; j++) {
					if (lerpFrames[0][i].id == lerpFrames[1][j].id) {
						lerpIndex = j;
						break;
					}
				}
				
				if (lerpIndex != -1) {
					PLAYERS[playerIndex].tarx = (1-t) * lerpFrames[0][i].position.x + t * lerpFrames[1][lerpIndex].position.x;
					PLAYERS[playerIndex].tary = (1-t) * lerpFrames[0][i].position.y + t * lerpFrames[1][lerpIndex].position.y;
				}
				else if (playerIndex != -1) {
					PLAYERS.splice(playerIndex, 1);
				}
			}
			
			var tick = (currentTime-prevTime) / (frameTimes[1] - frameTimes[0]);
			t += tick;
		}
		if (t >= 1.0) {
			while (lerpFrames.length > 2) {
				lerpFrames.splice(0, 1);
				frameTimes.splice(0, 1);
				t -= 1.0;
			}
			if (lerpFrames.length < 2) t = 1.0;
		}
		
		if (player !== undefined) {
			FRAME.x = -player.x*FRAME.scaleX + window.innerWidth/2;
			FRAME.y = -player.y*FRAME.scaleY + window.innerHeight/2;
		}
		
		collection.update();
		collection.draw();
		
		requestFrame(main);
	}
	
	function resetGame() {
		collection.clear();
		PLAYERS = [];
		
		if (bigbubble != undefined)
			collection.add(bigbubble);
	}
	
	function startGame() {
		var ip = (getParameterByName("ip") == null) ? "wss://buuuuble.herokuapp.com/" : getParameterByName("ip");
		keyboard = new Keyboard();
		//var ip = "ws://localhost:8080";
		ws = new WebSocket(ip);
		
		ws.onopen = function() {
			resetGame();
			
			ws.send("s" + document.getElementById("name").value);
			
			main();
		}
		ws.onmessage = function(m) {
			var message = m.data;
			var parsedMessage = JSON.parse(message);
			//update
			if (parsedMessage.t == 'u') {
				lerpFrames.push(parsedMessage.players);
				frameTimes.push(parsedMessage.tme);
			}
			//get id
			else if (parsedMessage.t == 'i') {
				playerid = parsedMessage.id;
			}
		}
		ws.onclose = function() {
			ws = null;
		}
		
		document.getElementById("startGUI").style.visibility = "hidden";
	}
	
	function getParameterByName(name, url) {
		if (!url) {
		url = window.location.href;
		}
		name = name.replace(/[\[\]]/g, "\\$&");
		var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
			results = regex.exec(url);
		if (!results) return null;
		if (!results[2]) return '';
		return decodeURIComponent(results[2].replace(/\+/g, " "));
	}
</script>
</html>